/*
  Multi-Module Stepper Motor Control using AccelStepper Library

  This code controls four modules, each containing four stepper motors (A, X, Y, Z),
  using the AccelStepper library. The stepper motors are driven in DRIVER mode, 
  where each motor is controlled by a step and direction pin.

  Command format:
  - Direct motor control: <module><motor><steps>
    e.g., "1X1000" moves module 1's X motor by 1000 steps
  
  - Module position reporting: get_module_positions <module>
    e.g., "get_module_positions 1" returns positions of all motors in module 1
  
  - Module running status: check_module_running <module>
    e.g., "check_module_running 2" checks if any motors in module 2 are running
  
  - Set absolute position: set_absolute_position <module><motor> <position>
    e.g., "set_absolute_position 1X 100000" sets module 1's X motor to position 100000
  
  - Shutter control: gsh on/off
    e.g., "gsh on" closes the shutter, "gsh off" opens it
  
  - Light sensor reading: ld0
    reads and returns the value from the light-dependent resistor
  
  - Mode commands: ramanmode, imagemode
    Switch between different operational modes
*/

#include <AccelStepper.h>

// Module 1 motors (previously "A" group - Laser motors)
AccelStepper stepperA1(AccelStepper::DRIVER, 22, 23);
AccelStepper stepperX1(AccelStepper::DRIVER, 24, 25);
AccelStepper stepperY1(AccelStepper::DRIVER, 26, 27);
AccelStepper stepperZ1(AccelStepper::DRIVER, 28, 29);

// Module 2 motors (previously "B" group - Monochromator motors)
AccelStepper stepperA2(AccelStepper::DRIVER, 30, 31);
AccelStepper stepperX2(AccelStepper::DRIVER, 32, 33);
AccelStepper stepperY2(AccelStepper::DRIVER, 34, 35);
AccelStepper stepperZ2(AccelStepper::DRIVER, 36, 37);

// Module 3 motors (available for future expansion)
AccelStepper stepperA3(AccelStepper::DRIVER, 38, 39);
AccelStepper stepperX3(AccelStepper::DRIVER, 40, 41);
AccelStepper stepperY3(AccelStepper::DRIVER, 42, 43);
AccelStepper stepperZ3(AccelStepper::DRIVER, 44, 45);

// Module 4 motors (available for future expansion)
AccelStepper stepperA4(AccelStepper::DRIVER, 46, 47);
AccelStepper stepperX4(AccelStepper::DRIVER, 48, 49);
AccelStepper stepperY4(AccelStepper::DRIVER, 50, 51);
AccelStepper stepperZ4(AccelStepper::DRIVER, 52, 53);

// Pin definitions
const int ldr0pin = A0;      // LDR input pin
const int gShutPin = 9;      // Grating shutter pin

// Variables
int ldr0value = 0;
volatile unsigned long counter = 0;

void setup() {
    Serial.begin(9600);
    
    // Create an array of all steppers for easy initialization
    AccelStepper* steppers[] = {&stepperA1, &stepperX1, &stepperY1, &stepperZ1,
                              &stepperA2, &stepperX2, &stepperY2, &stepperZ2,
                              &stepperA3, &stepperX3, &stepperY3, &stepperZ3,
                              &stepperA4, &stepperX4, &stepperY4, &stepperZ4};
    
    // Set default speed and acceleration for all motors
    for (int i = 0; i < 16; i++) {
        steppers[i]->setMaxSpeed(5000);
        steppers[i]->setAcceleration(5000);
    }
  
    // Custom speeds for specific motors
    stepperY4.setMaxSpeed(10000);
    stepperY4.setAcceleration(10000);
    stepperA4.setMaxSpeed(300);
    stepperA4.setAcceleration(1000);
    stepperA1.setMaxSpeed(1000);
    stepperA1.setAcceleration(1000);

    // Setup output pins
    pinMode(gShutPin, OUTPUT);
    digitalWrite(gShutPin, LOW);  // Initialize shutter as closed

    Serial.println("Arduino MEGA controller initialized");
    Serial.println("#CF");
}

void loop() {
    // Run all steppers
    // Module 1
    stepperA1.run(); stepperX1.run(); stepperY1.run(); stepperZ1.run();
    // Module 2
    stepperA2.run(); stepperX2.run(); stepperY2.run(); stepperZ2.run();
    // Module 3
    stepperA3.run(); stepperX3.run(); stepperY3.run(); stepperZ3.run();
    // Module 4
    stepperA4.run(); stepperX4.run(); stepperY4.run(); stepperZ4.run();

    // Process any incoming commands
    if (Serial.available() > 0) {
        String command = Serial.readStringUntil('\n');
        parseCommand(command);
        Serial.println("#CF");  // End of command flag
    }
}

// Mode commands
void ramanMode() {
    stepperA1.move(6000);
    Serial.println("Moving to Raman Mode...");
}

void imageMode() {
    stepperA1.move(-6000);
    Serial.println("Moving to Image Mode...");
}

// Hardware control commands
void monoShutter(String state) {
    if (state == "on") {
        digitalWrite(gShutPin, LOW);
        Serial.println("Shutter closed.");
    } else if (state == "off") {
        digitalWrite(gShutPin, HIGH);
        Serial.println("Shutter open.");
    }
}

void readLDR() {
    int count = 0;
    ldr0value = 0;
    while (count < 10) {
        ldr0value += analogRead(ldr0pin);
        count++;
    }
    Serial.print('t');
    Serial.println(ldr0value);
}

// Main command parser for direct motor control
void parseMotorCommand(String command) {
    // Direct motor command format: <module><motor><steps>
    // Examples: 1X1000, 2Y-500, etc.
    
    AccelStepper* steppers[] = {&stepperA1, &stepperX1, &stepperY1, &stepperZ1,
                              &stepperA2, &stepperX2, &stepperY2, &stepperZ2,
                              &stepperA3, &stepperX3, &stepperY3, &stepperZ3,
                              &stepperA4, &stepperX4, &stepperY4, &stepperZ4};

    // Extract module number (1-4)
    char module = command.charAt(0);
    if (module < '1' || module > '4') {
        Serial.println("Invalid module number (must be 1-4)");
        return;
    }
    int moduleIndex = (module - '1') * 4;  // Convert to 0-based index and multiply by 4

    // Extract motor letter (A, X, Y, Z)
    char motor = command.charAt(1);
    int motorOffset = 0;
    switch (motor) {
        case 'A': motorOffset = 0; break;
        case 'X': motorOffset = 1; break;
        case 'Y': motorOffset = 2; break;
        case 'Z': motorOffset = 3; break;
        default:
            Serial.println("Invalid motor letter (must be A, X, Y, Z)");
            return;
    }
    
    // Extract number of steps to move
    long steps = 0;
    if (command.length() > 2) {
        // Steps are directly in the command
        steps = command.substring(2).toInt();
    } else {
        Serial.println("Missing step value");
        return;
    }
    
    // Get the stepper and move it
    int motorIndex = moduleIndex + motorOffset;
    steppers[motorIndex]->move(steps);
    
    Serial.print("Moving module ");
    Serial.print(module);
    Serial.print(" motor ");
    Serial.print(motor);
    Serial.print(" by ");
    Serial.print(steps);
    Serial.println(" steps");
}

// Report the positions of all motors in a module
void reportModulePositions(int moduleNumber) {
    if (moduleNumber < 1 || moduleNumber > 4) {
        Serial.println("Invalid module number");
        return;
    }
    
    // Calculate the base index for this module's motors
    int baseIndex = (moduleNumber - 1) * 4;
    
    // Get references to the steppers in this module
    AccelStepper* steppers[] = {&stepperA1, &stepperX1, &stepperY1, &stepperZ1,
                              &stepperA2, &stepperX2, &stepperY2, &stepperZ2,
                              &stepperA3, &stepperX3, &stepperY3, &stepperZ3,
                              &stepperA4, &stepperX4, &stepperY4, &stepperZ4};
    
    // Format the response string: S0:<P>X123,Y456,Z789,A012</P>
    Serial.print("S0:<P>");
    
    // A motor in each module
    Serial.print("A");
    Serial.print(steppers[baseIndex]->currentPosition());
    Serial.print(",");
    
    // X motor
    Serial.print("X");
    Serial.print(steppers[baseIndex + 1]->currentPosition());
    Serial.print(",");
    
    // Y motor
    Serial.print("Y");
    Serial.print(steppers[baseIndex + 2]->currentPosition());
    Serial.print(",");
    
    // Z motor
    Serial.print("Z");
    Serial.print(steppers[baseIndex + 3]->currentPosition());
    
    Serial.println("</P>");
}

// Check if any motor in a module is running
void checkModuleRunning(int moduleNumber) {
    if (moduleNumber < 1 || moduleNumber > 4) {
        Serial.println("Invalid module number");
        return;
    }
    
    // Calculate the base index for this module's motors
    int baseIndex = (moduleNumber - 1) * 4;
    
    // Get references to the steppers in this module
    AccelStepper* steppers[] = {&stepperA1, &stepperX1, &stepperY1, &stepperZ1,
                              &stepperA2, &stepperX2, &stepperY2, &stepperZ2,
                              &stepperA3, &stepperX3, &stepperY3, &stepperZ3,
                              &stepperA4, &stepperX4, &stepperY4, &stepperZ4};
    
    // Check if any motor in this module is running
    bool running = false;
    for (int i = 0; i < 4; i++) {
        if (steppers[baseIndex + i]->isRunning()) {
            running = true;
            break;
        }
    }
    
    // Return status: R1 if running, S0 if stopped
    if (running) {
        Serial.print("R1:");
        Serial.println(moduleNumber);
    } else {
        Serial.print("S0:");
        Serial.println(moduleNumber);
    }
}

// Set the absolute position of a specific motor
void setAbsolutePosition(String motorId, long position) {
    if (motorId.length() != 2) {
        Serial.println("Invalid motor ID format");
        return;
    }
    
    int moduleNumber = motorId.charAt(0) - '0';
    char motorLetter = motorId.charAt(1);
    
    if (moduleNumber < 1 || moduleNumber > 4 || 
        (motorLetter != 'A' && motorLetter != 'X' && 
         motorLetter != 'Y' && motorLetter != 'Z')) {
        Serial.println("Invalid module or motor identifier");
        return;
    }
    
    // Calculate the array index for the stepper
    int baseIndex = (moduleNumber - 1) * 4;
    int motorIndex;
    
    switch (motorLetter) {
        case 'A': motorIndex = 0; break;
        case 'X': motorIndex = 1; break;
        case 'Y': motorIndex = 2; break;
        case 'Z': motorIndex = 3; break;
        default: return; // Should never reach here due to earlier check
    }
    
    AccelStepper* steppers[] = {&stepperA1, &stepperX1, &stepperY1, &stepperZ1,
                              &stepperA2, &stepperX2, &stepperY2, &stepperZ2,
                              &stepperA3, &stepperX3, &stepperY3, &stepperZ3,
                              &stepperA4, &stepperX4, &stepperY4, &stepperZ4};
    
    // Set the absolute position
    steppers[baseIndex + motorIndex]->setCurrentPosition(position);
    
    Serial.print("Position of motor ");
    Serial.print(motorId);
    Serial.print(" set to ");
    Serial.println(position);
}

// Main command parser
void parseCommand(String command) {
    // Handle different command formats
    if (command.startsWith("o") && command.endsWith("o")) {
        // Direct motor control commands
        parseMotorCommand(command.substring(1, command.length() - 1));
    }
    else if (command.startsWith("m") && command.endsWith("m")) {
        // Hardware control commands
        String content = command.substring(1, command.length() - 1);
        String com = content.substring(0, 3);
        String comvalstring = "";
        
        // Handle commands with parameters
        if (content.length() > 4) {
            comvalstring = content.substring(4); //Assumes space in message
        }

        if (com == "gsh") {
            monoShutter(comvalstring);
        } else if (com == "ld0") {
            readLDR();
        } else {
            Serial.println("Unknown hardware command.");
        }
    }
    // Mode commands
    else if (command == "imagemode") {
        imageMode();
    }
    else if (command == "ramanmode") {
        ramanMode();
    }
    // Module position reporting
    else if (command.startsWith("get_module_positions")) {
        // Format: get_module_positions <module_number>
        if (command.length() >= 22) {
            int moduleNumber = command.substring(20).toInt();
            reportModulePositions(moduleNumber);
        } else {
            Serial.println("Missing module number");
        }
    }
    // Module running status check
    else if (command.startsWith("check_module_running")) {
        // Format: check_module_running <module_number>
        if (command.length() >= 22) {
            int moduleNumber = command.substring(20).toInt();
            checkModuleRunning(moduleNumber);
        } else {
            Serial.println("Missing module number");
        }
    }
    // Set absolute position
    else if (command.startsWith("set_absolute_position")) {
        // Format: set_absolute_position <module><motor> <position>
        int firstSpace = command.indexOf(' ', 21);
        int secondSpace = command.indexOf(' ', firstSpace + 1);
        
        if (firstSpace > 0 && secondSpace > 0) {
            String motorId = command.substring(firstSpace + 1, secondSpace);
            long position = command.substring(secondSpace + 1).toInt();
            setAbsolutePosition(motorId, position);
        } else {
            Serial.println("Invalid set_absolute_position command format");
        }
    }
    // Handle unknown commands
    else {
        Serial.print("Unknown command: ");
        Serial.println(command);
    }
}