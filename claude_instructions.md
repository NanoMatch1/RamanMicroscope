Okay, in this project folder we have code that is required to run a special type of Raman microscope. This microscope uses a tunable excitation laser and there are separate modules in the code, called instruments, that are responsible for managing and performing specific functions required for the optical microscope. These typically revolve around the use of stepper motors and some electronics hardware such as light-dependent resistors for sensing of light levels and shutters for controlling the light.
The code is a little bit of a mess because there is remnants from multiple different versions, and I'm currently trying to consolidate the code with a new firmware. The firmware is provided in the file called arduino-code.txt, as well as in the folder arduino-mega-develop, so whichever of those you prefer to access is up to you.
Now a lot of this code needs to be refactored to manage the new format of data communication being sent to and from the microscope controller, this Arduino Mega. In the function motionControl.getMotorPositions, an example of how this should work is laid out as an example.
Your task is to pay close attention to the Arduino sketch code, reading the comments and the details contained therein, as well as this motion control function, in order to ascertain what the rest of the functions should look like when they are sending commands to and from this Arduino controller. I need you to go through sequentially this code and edit slash refactor the code using the new code structure format for communication with this new version of the firmware.
There are a few things that you need to keep in mind when you're editing this code. Firstly, it should be very readable. Primarily, I would like to favor detailed doc strings over comments throughout the code. Secondly, everything should be modular. I have designed each of these instrument classes so that each particular subclass can be swapped out with a different wrapped hardware. So that is to say the camera classes are all interchangeable if and when I need to change the camera on this setup. So maintaining modularity is key. Also, I'm trying to reduce as many interdependencies as possible. So if you can see strategies to implement that, then you're welcome to suggest it. But the primary concern really at this point is getting the code up and running as quickly as possible in a way that is fundamentally easy to maintain, keeping in mind things like the modularity and the readability.
The last thing to keep in mind is robustness. I want the code to be as capable of handling errors and issues that might appear as possible whilst still reporting on exactly what's happening. 
This microscope will be used by others, and it will be my job to maintain the code. So error reporting will be valuable, error logging will be valuable, and if the code can be written in such a way that it handles errors gracefully, whilst still being extremely readable, which is to say, wrapping complex function where appropriate, it will also be extremely helpful.
Start by examining the code that runs initially from interface_run_me.py, leading up to and including the first "MotionControl.get_motor_positions" call, after which the code will encounter an error as it tries to run legacy code which was intended for use with the old firmware and communicaton protocols.
You should query me for any details that you are unclear on, but your idea is to take this chain of runnable code and then implement the same template of changes in your refactoring of the rest of the code being executed by this interface runme.py.
The motors to be queried or moved at any given time are specified in the microscope.actiongroups dictionary. Inside this dictionary you will find human readable labels which correspond to the type of function that the motor does as the key and the value is a string which represents the Arduino code version of that stepper motor label. So you should reference the actiongroups dictionary in order to construct these functions for querying the laser motor positions and grating motor positions, keeping in mind that they can all use the same getMotorPosition function by feeding it the correct actiongroups dictionary.